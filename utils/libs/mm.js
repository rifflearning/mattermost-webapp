// Generated by CoffeeScript 2.3.2
(function() {
  // Data given to MM viz:
  // {'participants': [<participantId, participantId, ...],
  //  'names'?: [<participantName, participantName, ...],
  //  'transitions': <Number Of transitions in interval>,
  //  'turns': [{'participant': <participantId>,
  //             'turns': <Percent of turns in interval by this participant>}, ...]
  var ENERGY_NODE_RADIUS, MM, NETWORK_RADIUS, PARTICIPANT_NODE_COLOR_LOCAL, PARTICIPANT_NODE_COLOR_OTHER, PARTICIPANT_NODE_RADIUS, d3, linksFromData, nodesFromData;

  d3 = require('./d3').default;

  NETWORK_RADIUS = 115 * 2 / 3;

  PARTICIPANT_NODE_RADIUS = 20 * 2 / 3;

  ENERGY_NODE_RADIUS = 30 * 2 / 3;

  PARTICIPANT_NODE_COLOR_LOCAL = '#4a4a4a';

  PARTICIPANT_NODE_COLOR_OTHER = '#3AC4C5';

  // get array of participant nodes from data
  nodesFromData = function(data) {
    var i, nodes, p;
    nodes = (function() {
      var j, len, ref, ref1, ref2, results;
      ref = data.participants;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        p = ref[i];
        results.push({
          'participant': p,
          'name': ((ref1 = (ref2 = data.names) != null ? ref2[i] : void 0) != null ? ref1 : p)[0]
        });
      }
      return results;
    })();
    console.log("nodes:", nodes);
    nodes.push({
      'participant': 'energy' // keep the energy ball in the list of nodes
    });
    return nodes;
  };

  // create links, 1 link to the energy ball for each participant
  // give it a 0 default weight
  linksFromData = function(data) {
    var links, p;
    links = (function() {
      var j, len, ref, results;
      ref = data.participants;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        results.push({
          'source': p,
          'target': 'energy',
          'weight': 0
        });
      }
      return results;
    })();
    return links;
  };

  // exported MeetingMediator class
  module.exports.MeetingMediator = MM = class MM {
    constructor(data1, localParticipants, width, height, peerColors, riffIds, localId) {
      // d3func - node radius based on participant
      this.nodeRadius = this.nodeRadius.bind(this);
      // d3func - different colors for different types of nodes...
      this.nodeColor = this.nodeColor.bind(this);
      //        PARTICIPANT_NODE_COLOR_OTHER

      // d3func - we have different kinds of nodes, so this just abstracts
      // out the transform function.
      this.nodeTransform = this.nodeTransform.bind(this);
      // d3func - a translation between the angle rotation for nodes
      // and the raw x/y positions. Used for computing link endpoints.
      this.getNodeCoords = this.getNodeCoords.bind(this);
      // d3func - translation / position for "energy" ball.
      // Moves closer (just based on weighting) to nodes.
      this.sphereTranslation = this.sphereTranslation.bind(this);
      // d3func - This returns a translation string to rotate the _entire_
      // "graph group" to keep the user's node at the top.
      this.constantRotation = this.constantRotation.bind(this);
      this.data = data1;
      this.localParticipants = localParticipants;
      console.log("constructing MM with data:", this.data);
      this.fontFamily = "Futura,Helvetica Neue,Helvetica,Arial,sans-serif";
      this.margin = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      this.width = width - this.margin.right - this.margin.left;
      this.height = height - this.margin.bottom - this.margin.top;
      this.peerColors = peerColors;
      this.riffIds = riffIds;
      this.remoteParticipants = [...this.data.participants.slice(0, this.data.participants.indexOf(this.localParticipants[0])), ...this.data.participants.slice(this.data.participants.indexOf(this.localParticipants[0]) + 1)];
      // @nodeColorScale = d3.scaleOrdinal()
      //       .domain @remoteParticipants
      //       .range @peerColors
      this.nodeColorScale = (p) => {
        var idx;
        idx = this.remoteParticipants.indexOf(p);
        return this.peerColors[idx];
      };
      // radius of network as a whole
      this.radius = NETWORK_RADIUS;
      // distributes positions for participant avatars evenly in a circle
      this.angle = d3.scalePoint().domain(this.data.participants).range([0, 360]).padding(0.5);
      // determines thickness of edges
      this.linkStrokeScale = d3.scaleLinear().domain([0, 1]).range([3, 15]);
      // color scale for sphere in the middle
      this.sphereColorScale = d3.scaleLinear().domain([-5, this.data.participants.length * 3]).range(['#f5f5f5', '#9d7dae']).clamp(true);
      // create initial node data
      this.nodes = nodesFromData(this.data);
      this.links = linksFromData(this.data);
      this.updateLinkWeight();
      this.nodeTransitionTime = 500;
      this.linkTransitionTime = 500;
    }

    nodeRadius(d) {
      if (d.participant === "energy") {
        return ENERGY_NODE_RADIUS;
      } else {
        return PARTICIPANT_NODE_RADIUS;
      }
    }

    render(id = "#meeting-mediator") {
      this.chart = d3.select(id).append("svg").attr("class", "meeting-mediator").attr("width", this.width + this.margin.left + this.margin.right).attr("height", this.height + this.margin.top + this.margin.bottom).append("g").attr("transform", `translate(${this.width / 2},${this.height / 2})`);
      this.chartBody = this.chart.append("g").attr("width", this.width).attr("height", this.height);
      this.graphG = this.chart.append("g").attr("width", this.width).attr("height", this.height);
      // keeps user node at top
      this.graphG.transition().attr("transform", this.constantRotation()); //.duration(250)
      this.outline = this.chartBody.append("g").attr("id", "outline").append("circle").style("stroke", "#AFAFAF").attr("stroke-width", 3).style("stroke-dasharray", "10, 5").attr("fill", "transparent").attr("r", this.radius + PARTICIPANT_NODE_RADIUS + 2);
      // put links / nodes in a separate group
      this.linksG = this.graphG.append("g").attr("id", "links");
      this.nodesG = this.graphG.append("g").attr("id", "nodes");
      this.renderNodes();
      return this.renderLinks();
    }

    // a little complicated, since we want to be able to put text
    // and prettier stuff on nodes in the future (maybe).
    // We create a group for each node, and do a selection for moving them around.
    renderNodes() {
      var nodeGs, nodeGsEnter;
      nodeGs = this.nodesG.selectAll(".node").data(this.nodes, function(d) {
        return d.participant;
      });
      // remove node groups for nodes that have left
      nodeGs.exit().remove();
      // new node groups - add attributes and child elements
      nodeGsEnter = nodeGs.enter().append("g").attr("class", "node").attr("id", function(d) {
        return d.participant;
      });
      nodeGsEnter.append("circle").attr("class", "nodeCircle").attr("fill", this.nodeColor).attr("r", this.nodeRadius);
      nodeGsEnter.append("circle").attr("class", "nodeFill").attr("fill", "#FFFFFF").attr("r", (d) => {
        if (d.participant === 'energy' || this.localParticipants.includes(d.participant)) {
          return 0;
        } else {
          return this.nodeRadius(d) - 3;
        }
      });
      nodeGsEnter.append("text").attr("text-anchor", "middle").attr("font-size", "24px").attr("dy", ".35em").attr("transform", (d) => {
        if (d.participant === 'energy') {
          return "";
        } else {
          return `rotate(${-1 * (this.constantRotationAngle() + this.angle(d.participant))})`;
        }
      }).attr("fill", (d) => {
        if (this.localParticipants.includes(d.participant)) {
          return "#FFFFFF";
        } else {
          return "#000000";
        }
      });
      //.text (d) -> d.name

      // all node groups
      return this.nodesG.selectAll(".node").transition().duration(500).attr("transform", this.nodeTransform).select('circle').attr("fill", this.nodeColor); // change circle color
    }

    nodeColor(d) {
      if (d.participant === 'energy') {
        return this.sphereColorScale(this.data.transitions);
      } else if (this.localParticipants.includes(d.participant)) {
        return PARTICIPANT_NODE_COLOR_LOCAL;
      } else {
        return this.nodeColorScale(d.participant);
      }
    }

    nodeTransform(d) {
      if (d.participant === "energy") {
        return this.sphereTranslation();
      } else {
        return `rotate(${this.angle(d.participant)})translate(${this.radius},0)`;
      }
    }

    getNodeCoords(id) {
      var t, transformText;
      transformText = this.nodeTransform({
        'participant': id
      });
      t = MM.getTransformation(transformText);
      return {
        'x': t.translate.x,
        'y': t.translate.y
      };
    }

    renderLinks() {
      var linkGs;
      linkGs = this.linksG.selectAll("line.link").data(this.links, function(d) {
        return d.source;
      });
      // remove links for participants who have left
      linkGs.exit().remove();
      // add links for new participants
      linkGs.enter().append("line").attr("class", "link").attr("stroke", "#646464").attr("fill", "none").attr("stroke-opacity", 0.8).attr("stroke-width", 7).attr("x1", (d) => {
        return this.getNodeCoords(d.source)['x'];
      }).attr("y1", (d) => {
        return this.getNodeCoords(d.source)['y'];
      }).attr("x2", (d) => {
        return this.getNodeCoords(d.target)['x'];
      }).attr("y2", (d) => {
        return this.getNodeCoords(d.target)['y'];
      });
      // update existing links
      linkGs.attr("x1", (d) => {
        return this.getNodeCoords(d.source)['x'];
      }).attr("y1", (d) => {
        return this.getNodeCoords(d.source)['y'];
      }).attr("x2", (d) => {
        return this.getNodeCoords(d.target)['x'];
      }).attr("y2", (d) => {
        return this.getNodeCoords(d.target)['y'];
      });
      // all links
      return this.linksG.selectAll("line.link").transition().duration(this.linkTransitionTime).attr("stroke-width", (d) => {
        return this.linkStrokeScale(d.weight);
      });
    }

    sphereTranslation() {
      var coords, j, len, node_x, node_y, ref, turn, x, xDist, y, yDist;
      x = 0;
      y = 0;
      ref = this.data.turns;
      for (j = 0, len = ref.length; j < len; j++) {
        turn = ref[j];
        coords = this.getNodeCoords(turn.participant);
        // get coordinates of this node & distance from ball
        node_x = coords['x'];
        node_y = coords['y'];
        xDist = node_x - x;
        yDist = node_y - y;
        // transform x and y proportional to the percentage of turns
        // (and use dist/2 to prevent collision)
        x += turn.turns * (xDist / 2);
        y += turn.turns * (yDist / 2);
      }
      return `translate(${x},${y})`;
    }

    // the angle to rotate the graph by to put the user's node at the top.
    constantRotationAngle() {
      var a, angle, targetAngle;
      // TODO unsure about this
      angle = this.angle(this.localParticipants[0]) || 0;
      targetAngle = -90;
      a = targetAngle - angle;
      a = (a + 180) % 360 - 180;
      if (angle !== -90) {
        return a;
      } else {
        return 0;
      }
    }

    constantRotation() {
      return `rotate(${this.constantRotationAngle()})`;
    }

    // update the link weight from current turn data
    updateLinkWeight() {
      var j, len, link, ref, ref1, ref2;
      ref = this.links;
      for (j = 0, len = ref.length; j < len; j++) {
        link = ref[j];
        link.weight = (ref1 = (ref2 = this.data.turns.find((turn) => {
          return turn.participant === link.source;
        })) != null ? ref2.turns : void 0) != null ? ref1 : 0;
      }
    }

    updateData(data) {
      console.log("updating MM viz with data:", data);
      data.participants = data.participants.sort();
      this.remoteParticipants = [...data.participants.slice(0, data.participants.indexOf(this.localParticipants[0])), ...data.participants.slice(data.participants.indexOf(this.localParticipants[0]) + 1)];
      // if we're not updating participants, don't redraw everything.
      console.log("local participant:", this.localParticipants[0]);
      console.log("remote participants:", this.remoteParticipants);
      console.log("beginning:", data.participants.slice(0, data.participants.indexOf(this.localParticipants[0])));
      console.log("end", data.participants.slice(data.participants.indexOf(this.localParticipants[0]) + 1));
      console.log("color:", this.remoteParticipants.map((p) => {
        return this.nodeColorScale(p);
      }));
      if (data.participants.length === this.data.participants.length) {
        this.data = data;
        this.updateLinkWeight();
        this.renderLinks();
        return this.renderNodes();
      } else {
        // Create nodes again
        this.data = data;
        this.nodes = nodesFromData(this.data);
        this.links = linksFromData(this.data);
        this.updateLinkWeight();
        // recompute the color scale for the sphere and angle domain
        this.sphereColorScale.domain([0, data.participants.length * 5]);
        this.angle.domain(this.data.participants);
        // recompute links
        this.link = this.linksG.selectAll("line.link").data([]).exit().remove();
        // Re-render. Do it on a delay to make sure links get rendered after nodes.
        // After links, rotate entire graph so user is at top.
        this.renderNodes();
        return setTimeout((() => {
          return this.graphG.transition().duration(0).attr("transform", this.constantRotation());
        }), this.renderLinks(), this.nodeTransitionTime + 100);
      }
    }

    // Function copied pretty much verbatim from stackoverflow for replacing use of
    // the V3 d3.transform when moving to d3 V4
    // https://stackoverflow.com/questions/38224875/replacing-d3-transform-in-d3-v4
    static getTransformation(transform) {
      var a, b, c, d, e, f, g, identityMatrix, matrix, ref, ref1, scaleX, scaleY, skewX;
      // Create a dummy g for calculation purposes only. This will never
      // be appended to the DOM and will be discarded once this function
      // returns.
      g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      // Set the transform attribute to the provided string value.
      g.setAttributeNS(null, "transform", transform);
      // consolidate the SVGTransformList containing all transformations
      // to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
      // its SVGMatrix.
      identityMatrix = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      matrix = (ref = (ref1 = g.transform.baseVal.consolidate()) != null ? ref1.matrix : void 0) != null ? ref : identityMatrix;
      // Below calculations are taken and adapted from the private function
      // transform/decompose.js of D3's module d3-interpolate.
      ({a, b, c, d, e, f} = matrix);
      if (scaleX = Math.sqrt(a * a + b * b)) {
        a /= scaleX;
        b /= scaleX;
      }
      if (skewX = a * c + b * d) {
        c -= a * skewX;
        d -= b * skewX;
      }
      if (scaleY = Math.sqrt(c * c + d * d)) {
        c /= scaleY;
        d /= scaleY;
        skewX /= scaleY;
      }
      if (a * d < b * c) {
        a = -a;
        b = -b;
        skewX = -skewX;
        scaleX = -scaleX;
      }
      return {
        translate: {
          x: e,
          y: f
        },
        rotate: Math.atan2(b, a) * 180 / Math.PI,
        skewX: Math.atan(skewX) * 180 / Math.PI,
        scale: {
          x: scaleX,
          y: scaleY
        }
      };
    }

  };

}).call(this);
